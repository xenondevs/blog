{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"2023/03/03/runtime-patching-in-nova/","title":"Runtime patching in Nova","text":""},{"location":"2023/03/03/runtime-patching-in-nova/#introduction","title":"Introduction","text":"<p>Patching is a pretty common practice in most modding communities. Sometimes it's even the only way to add specific features to a game. Minecraft is no exception here. Most of the time, modding frameworks use 1 of 2 main approaches to modify Minecraft's code. The first way is decompiling Minecraft, applying predefined patch files to the decompiled code and finally, recompiling the entire server. These patch files are usually using git's diff format. As an example, here's one of the patches applied when running BuildTools to ensure the correct <code>CommandDispatcher</code> is used:</p> <pre><code>--- a/net/minecraft/server/CustomFunctionData.java\n+++ b/net/minecraft/server/CustomFunctionData.java\n@@ -42,7 +42,7 @@\n     }\n\n     public CommandDispatcher&lt;CommandListenerWrapper&gt; getDispatcher() {\n-        return this.server.getCommands().getDispatcher();\n+        return this.server.vanillaCommandDispatcher.getDispatcher(); // CraftBukkit\n     }\n\n     public void tick() {\n</code></pre> <p>Paper and its forks use a similar approach. But instead of forcing users to build the server themselves via a tool like BuildTools, they apply the patches and generate a binary diff between the vanilla Minecraft server and their patched version. This binary diff is then used to generate Paper's server jar using PaperClip.</p> <p>And then there's client- and serverside modding frameworks like Forge, Fabric and Sponge. These frameworks use Mixins and also allow the framework uses to add their own. Unlike Bukkit's approach, Mixins are written in code which already enhances the qol for devs. They allow you to inject code or even add fields and interface implementations to any class. They're also applied directly before startup instead of generating a patched server jar. Here's a Mixin that prevents oversized books from being created:</p> <pre><code>@Mixin(WritableBookItem.class)\npublic abstract class WritableBookItemMixin_LimitBookSize {\n\n    @Redirect(\n            method = \"makeSureTagIsValid\",\n            at = @At(value = \"INVOKE\", remap = false, target = \"Ljava/lang/String;length()I\")\n    )\n    private static int impl$useByteLength(final String s) {\n        return s.getBytes(StandardCharsets.UTF_8).length;\n    }\n\n    @ModifyConstant(\n            method = \"makeSureTagIsValid\",\n            constant = @Constant(intValue = 32767)\n    )\n    private static int impl$useMaxBookPageSizeFromConfig(final int maxBookPageSize) {\n        return SpongeConfigs.getCommon().get().exploits.maxBookPageSize;\n    }\n\n    @Inject(\n            method = \"makeSureTagIsValid\",\n            cancellable = true,\n            at = @At(value = \"RETURN\")\n    )\n    private static void impl$useMaxBookSizeFromConfig(final CompoundTag p_150930_0_, final CallbackInfoReturnable&lt;Boolean&gt; cir) {\n        if (cir.getReturnValue()) {\n            final ListTag listnbt = p_150930_0_.getList(\"pages\", 8);\n            final int size = IntStream.range(0, listnbt.size()).mapToObj(listnbt::getString).mapToInt(s -&gt; s.getBytes(StandardCharsets.UTF_8).length).sum();\n            if (size &gt; SpongeConfigs.getCommon().get().exploits.maxBookSize) {\n                cir.setReturnValue(false);\n            }\n        }\n    }\n\n}\n</code></pre> <p>So why do none of these approaches work for Nova?</p> What's Nova? <p>Nova (GitHub) is a modding framework we're currently working on that allows developers to add custom items, blocks, GUIs and more to Spigot servers via resource packs. Check out our Spigot thread if you want to learn more about the resource pack stuff.</p>"},{"location":"2023/03/03/runtime-patching-in-nova/#the-problem","title":"The problem","text":"<p>Unlike all previously mentioned modding frameworks, Nova isn't built into the server. Instead, it's a Spigot plugin which causes a few problems. Most classes we need to patch are already loaded by a <code>ClassLoader</code> before Nova is even loaded. Sadly, The JVM will not let you define the same class again (even when using <code>Unsafe#defineClass</code>). Getting rid of the existing definition is also hard since the JVM uses a so-called system dictionary internally which maintains a mapping between class names and their corresponding class definitions. This dictionary makes removing an existing class definition pretty much impossible without writing native code that directly edits memory sections (which would obviously be a bad idea in itself).</p>"},{"location":"2023/03/03/runtime-patching-in-nova/#instrumentation","title":"Instrumentation","text":"<p>Luckily, the designers of the JVM thought about this problem and built a solution for it. Most JVM implementations support a feature called Instrumentation . <code>Instrumentation</code> allows us to modify the bytecode of classes that are already loaded by the JVM. This is exactly what we need to patch Minecraft's classes. But getting an <code>Instrumentation</code> instance is not easy. The constructor of the <code>InstrumentationImpl</code> class has a <code>long nativeAgent</code> parameter, which is used to pass a pointer of the JPLISAgent. So it's not possible to get an instance without attaching an agent to the current JVM. But what even is a Java agent? A Java agent is a program that can be loaded into the JVM at runtime to provide additional functionality. It is mostly used for debugging or performance monitoring, but can also be used to modify the behavior of a running Java application. Java agents can access the JVM's internal data structure (i.e. the previously mentioned system dictionary) and modify it. Normally, java agents are loaded by the JVM during startup via the <code>-javaagent</code> command line argument. Attaching an agent to a running JVM is also possible. The runtime attaching mechanism can also get a bit complicated when supporting multiple JDK distributions, but luckily byte-buddy exists. Byte-buddy is a library that allows us to attach a java agent without having to write any native code. It's normally used to create dynamic proxies at runtime via <code>Instrumentation</code>. However, the agent attachment mechanism is located in a different module, so we don't have to include the entire library and can just call <code>ByteBuddyAgent.install()</code> to attach an agent and get an <code>Instrumentation</code> instance.</p>"},{"location":"2023/03/03/runtime-patching-in-nova/#patching","title":"Patching","text":"<p>Now that we have an <code>Instrumentation</code> instance, we can start patching classes. In Nova, we created a simple <code>Transformer</code> interface:</p> <pre><code>internal sealed interface Transformer {\n\n    val classes: Set&lt;KClass&lt;*&gt;&gt;\n\n    val computeFrames: Boolean\n\n    fun transform()\n\n    fun shouldTransform(): Boolean = true\n\n}\n</code></pre> <p>This interface contains a <code>classes</code> property to specify which classes will be updated by this Transformer (and thus should be redefined) and a <code>computeFrames</code> property that states whether ASM should recompute the stack frames of the newly updated class. We also added a couple of abstract implementations of the <code>Transformer</code> interface like <code>ClassTransformer</code>, <code>MethodTransformer</code>, <code>MultiTransformer</code> or even <code>ReversibleClassTransformer</code>. The names should be pretty self-explanatory.</p>"},{"location":"2023/03/03/runtime-patching-in-nova/#classloader-issue","title":"Classloader issue","text":"<p>When writing our first patch, we already ran into our first problem. We wanted to patch the <code>NoteBlock</code> class to override the sound logic since the note is no longer stored in the blockstate (See our spigot thread if you're not familiar with the resource pack tricks). We'd obviously need to check our own data on the current block to determine which sound to play, or if a sound should be played at all. However, we can't access Nova classes from the <code>NoteBlock</code> class, since they're loaded via Bukkits <code>PluginClassLoader</code> and therefore aren't visible to the <code>NoteBlock</code> class. So we had to find a way to squeeze Nova's <code>ClassLoader</code> into Minecraft's class loading hierarchy. So the obvious first step was to look at Java's <code>ClassLoader</code> class, where we quickly noticed the following field:</p> <pre><code>// The parent class loader for delegation\nprivate final ClassLoader parent;\n</code></pre> <p>This field is used to delegate class loading to the parent <code>ClassLoader</code> if the current one can't find a requested class. So we just need to replace this field with a custom <code>ClassLoader</code> that first checks the original <code>ClassLoader</code> and then delegates to Nova's <code>ClassLoader</code>:</p> <pre><code>internal class PatchedClassLoader : ClassLoader(NOVA.loader.javaClass.classLoader.parent.parent) {\n\n    private val novaClassLoader = NOVA.javaClass.classLoader as NovaClassLoader\n\n    override fun loadClass(name: String, resolve: Boolean): Class&lt;*&gt; {\n        // Check if class is already loaded\n        var c: Class&lt;*&gt;? = synchronized(getClassLoadingLock(name)) { findLoadedClass(name) }\n\n        // Load class from parent (ApplicationClassLoader)\n        if (c == null) {\n            c = runCatching { parent.loadClass(name) }.getOrNull()\n        }\n\n        // Load class from Nova &amp; libraries\n        if (c == null &amp;&amp; checkNonRecursiveStackTrace()) {\n            // Restarts the class loading process at the NovaClassLoader\n            return novaClassLoader.loadClass(name, resolve)\n        }\n\n        if (c == null) {\n            throw ClassNotFoundException(name)\n        }\n\n        // Resolve class\n        if (resolve) {\n            synchronized(getClassLoadingLock(name)) { resolveClass(c) }\n        }\n\n        return c\n    }\n\n    /**\n     * Checks that a class load was not caused by Nova or another plugin.\n     */\n    private fun checkNonRecursiveStackTrace(): Boolean {\n        return Thread.currentThread().stackTrace\n            .none {\n                it.className == \"org.bukkit.plugin.java.PluginClassLoader\" || it.className == \"xyz.xenondevs.nova.loader.NovaClassLoader\"\n            }\n    }\n\n}\n</code></pre> <p>As you can see, we also had to add an extra check to prevent recursion in class loading, which would lead to a deadlock. With this <code>ClassLoader</code> in place, the new class loader hierarchy looks like this:</p> <p> </p> <p>But of course, things are never as easy as they seem... Firstly, it's normally not possible to get the reflection <code>Field</code> instance of the <code>parent</code> field because of a hard-coded filter in the JVM. Whenever getting fields of a class via reflection, a call to <code>Reflection#filterFields</code> is made.</p> <pre><code>private Field[] privateGetDeclaredFields(boolean publicOnly) {\n    Field[] res;\n    /* ... */\n    res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));\n    /* ... */\n    return res;\n}\n</code></pre> <p>This method exists to prevent access to certain fields that are meant to only be accessible inside internal code. Apparently, all fields of the <code>ClassLoader</code> class fit into this category, as shown in the <code>fieldFilterMap</code> used by the <code>Reflection#filterFields</code> method:</p> <pre><code>fieldFilterMap = Map.of(\n    /* ... */\n    ClassLoader.class, ALL_MEMBERS,\n    /* ... */\n);\n</code></pre> <p>So we had to write a patch that always returns the same list instead of filtering anything (and reverse it after we're done to prevent incompatibility with other plugins):</p> <pre><code>internal object FieldFilterPatch : ReversibleMethodTransformer(Reflection::filterFields.javaMethod!!) {\n\n    override fun transform() {\n        methodNode.instructions = buildInsnList {\n            aLoad(1) // Field[] fields parameter\n            areturn() // Return fields without applying any changes\n        }\n    }\n\n}\n</code></pre> <p>Now we just need to redefine a few modules to add Nova's module to the opens list:</p> <pre><code>private val extraOpens = setOf(\"java.lang\", \"java.lang.reflect\", \"java.util\", \"jdk.internal.misc\", \"jdk.internal.reflect\")\n\n// ...\n\nprivate fun redefineModule() {\n    val novaModule = setOf(Nova::class.java.module)\n    val javaBase = Field::class.java.module\n\n    INSTRUMENTATION.redefineModule(\n        javaBase,\n        emptySet(),\n        emptyMap(),\n        extraOpens.associateWith { novaModule },\n        emptySet(),\n        emptyMap()\n    )\n}\n</code></pre> <p>And finally, replace the <code>parent</code> field using <code>Unsafe</code> (since the field is final):</p> <pre><code>val spigotLoader = NOVA.loader.javaClass.classLoader.parent\nReflectionUtils.setFinalField(classLoaderParentField, spigotLoader, PatchedClassLoader())\n\n// ReflectionUtils code:\n\ninternal fun setFinalField(field: Field, obj: Any, value: Any?) {\n    val unsafe = Unsafe.getUnsafe()\n    val offset = unsafe.objectFieldOffset(field)\n    unsafe.putReference(obj, offset, value)\n}\n</code></pre> <p>NoteBlock block updates with an injected <code>println</code></p>"},{"location":"2023/03/03/runtime-patching-in-nova/#limitations-and-the-future-of-our-patching-system","title":"Limitations and the future of our patching system","text":"<p>There is still a pretty big limitation with runtime patching that doesn't exist when patching before the class is loaded. You can only change the instructions of methods. You can't add/remove methods, add interfaces, make fields public, etc. However, it has still allowed us to add a lot of features to Nova including our upcoming world generation support which would've been impossible without runtime patching. But there are ways to get around these limitations by proxying calls to added fields/methods, creating runtime wrapper classes for adding interfaces, etc. I'm also not a fan of the whole writing bytecode by hand thing. It's pretty error-prone and often hard to debug. That's why I'm currently working on a patching framework built into my bytecode library ByteBase. The syntax will be similar to mixins and will autogenerate stuff like the proxy calls I mentioned earlier. I'll probably write a blog post about it once it's finished.</p>"},{"location":"archive/2023/","title":"2023","text":""},{"location":"category/nova/","title":"Nova","text":""},{"location":"category/bytecode/","title":"Bytecode","text":""},{"location":"category/jvm/","title":"JVM","text":""},{"location":"category/minecraft/","title":"Minecraft","text":""}]}